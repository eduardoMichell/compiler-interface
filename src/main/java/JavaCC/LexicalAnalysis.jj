options {
}

PARSER_BEGIN(LexicalAnalysis)
import java.io.*;

public class LexicalAnalysis {
    public static void main(String[] args) throws ParseException, IOException {
//           LexicalAnalysis parser = new LexicalAnalysis(System.in);
           LexicalAnalysis parser = new LexicalAnalysis(new FileInputStream(args[0]));
           parser.MainRule();
    }
}
PARSER_END(LexicalAnalysis)

SKIP: { " " | "\t" | "\n" | "\r" }

TOKEN : {
      <DO: ("do")>
    | <IS: "is">
    | <AS: "as">
    | <AND: "and">
    | <ALL: "all">
    | <THIS: "this">
    | <BODY: "body">
    | <TYPE: "type">
    | <REAL: "real">
    | <STRING: "string">
    | <LOGIC: "logic">
    | <READ: "read">
    | <WRITE: "write">
    | <REPEAT: "repeat">
    | <VARIABLE: "variable">
    | <CONSTANT: "constant">
    | <RESULT: "result">
    | <INTEGER: "integer">
    | <AVALIATE: "avaliate">
    | <DESCRIPTION: "description">
    | <DECLARATION: "declaration">
    | <DESIGNATE: "designate">
}

TOKEN : {
      <TRUE: "true">
    | <UNTRUE: "untrue">
}

TOKEN : {
      <NOT_EQUAL: "!=">
    | <EQUAL: "==">
    | <GREATERTHEN: ">>">
    | <LESSTHEN: "<<">
    | <LESS_EQUALS: "<<=">
    | <GREATER_EQUALS: ">>=">
}
TOKEN : {
       <OR_LOGIC: "|">
     | <AND_LOGIC: "&">
     | <NEGATE_LOGIC : "!">
}

TOKEN : {
      <PLUS: "+">
    | <SUBTRACTION: "-">
    | <MULTIPLY: "*">
    | <DIVISION: "/">
    | <INTEGER_DIVISION: "%">
    | <DIVISION_REMAINDER: "%%">
    | <POTENCE: "**">
}

TOKEN : {
      <SEMI_COLUMN: ",">
    | <DOT: ".">
}

TOKEN : {
      <OPEN_KEYS: "{">
    | <CLOSE_KEYS: "}">
    | <OPEN_BOX: "[">
    | <CLOSE_BOX: "]">
    | <OPEN_BRACKETS: "(">
    | <CLOSE_BRACKETS: ")">
}

TOKEN : {
    <ASCII: (~[])>
  | <DIGIT: ["0"-"9"]>
  | <SYMBOL: ["_"]>
  | <MINUS: ("-"){1}>
  | <SINGLE_QUOTE: "'">
  | <DOUBLE_QUOTE: "\"">
  | <LETTER: ["A"-"Z","a"-"z"]>
  | <SMALL_LETTER : ["a"-"z"]>
  | <CAPITAL_LETTER : ["A"-"Z"]>
}

TOKEN : {
      <NUMERIC_CONSTANT  : <DIGIT> (<INTEGER_NUMERICAL_CONSTANT> | <REAL_NUMERICAL_CONSTANT>)>
    | <INTEGER_NUMERICAL_CONSTANT : (<DIGIT>)? (<DIGIT>)?>
    | <REAL_NUMERICAL_CONSTANT : (<DIGIT>)? (<DIGIT>)? (<DIGIT>)? (<DIGIT>)? <DOT> <DIGIT>(<DIGIT>)? (<DIGIT>)?>
}

TOKEN : {
      <LITERAL_CONSTANT  : <DOUBLE_QUOTE> (<ASCII>)* <DOUBLE_QUOTE> |
                           <SINGLE_QUOTE> (<ASCII>)* <SINGLE_QUOTE>>
}

TOKEN : {
       <IDENTIFIER  : <CAPITAL_LETTER>
                      (
                          ((<LETTER>)) |
                          (<DOUBLE_DIGIT>) |
                          ((<SYMBOL>))
                      )*>
     | <DOUBLE_DIGIT : (<DIGIT>(<DIGIT>)?)?>

}

TOKEN : {
      <MULTILINE_COMMENT : <MULTILINE_COMMENT_OPEN> (<ASCII>)* <MULTILINE_COMMENT_CLOSE>>
    | <MULTILINE_COMMENT_OPEN : "/*">
    | <MULTILINE_COMMENT_CLOSE :"*/">
}

TOKEN : {
      <SINGLELINE_COMMENT : <SINGLELINE_COMMENT_OPEN> (<ASCII>)*>
    | <SINGLELINE_COMMENT_OPEN : "//">

}

TOKEN : {
      <RESERVED_WORD  : <LETTER> <LETTER> (<LETTER>)*>
}

TOKEN : {
    <ASSIGNMENT_COMMAND : <DESIGNATE> <THIS> <AS> <EXPRESSION>>
    | <EXPRESSION : <INTEGER> | <REAL> | <STRING> | <LOGIC>>
}

TOKEN : {
    <TESTE : <ASCII>>
}

void enumDeclaration() : { }{
   <DECLARATION> <TYPE> <OPEN_BOX> (identifierDeclarationList())+ <CLOSE_BOX>
}

void identifierDeclarationList():{} {
   <IDENTIFIER> <IS> <OPEN_KEYS> constantIdentifierList() <CLOSE_KEYS> <DOT>
}

void constantIdentifierList(): {} {
    twoOrMoreConstants() | constantsDeclaration()
}

void twoOrMoreConstants(): {} {
  constantsDeclaration() <SEMI_COLUMN> (constantsDeclaration() <SEMI_COLUMN>)* constantsDeclaration()
}

void constantsDeclaration(): {} {
  <NUMERIC_CONSTANT> | <LITERAL_CONSTANT>
}


void MainRule():{}{
    enumDeclaration()
}

void lexicalAnalyzer():{
    Token t;
}{
     t=<DECLARATION> {System.out.println("TESTE:" + t.image);}
}

