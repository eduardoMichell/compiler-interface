package parser;/* LangParser.java */
/* Generated By:JavaCC: Do not edit this line. LangParser.java */

import java.io.*;

import parser.First;
import parser.Instruction;
import parser.RecoverySet;
import parser.LanguageRules;

import java.util.List;
import java.util.ArrayList;

public class LangParser implements LangParserConstants {
    int contParseError = 0;
    private String result = "";
    private boolean validLexical = true;
    private boolean validSyntax = true;
    static List<ErrorStruct> output = new ArrayList<ErrorStruct>();
    static List<String> commandList = new ArrayList<String>();
    static List<String> paramList = new ArrayList<String>();
    static LanguageRules languageRules = new LanguageRules();
    boolean eof;

    public String getResult() {
        return result;
    }

    public int getContParseError() {
        return contParseError;
    }

    public List<ErrorStruct> getOutput() {
        return output;
    }

    public void setOutput(List<ErrorStruct> newOutput) {
        output = newOutput;
    }

    public void setResult(String result) {
        this.result = result;
    }

    public boolean isValidLexical() {
        return validLexical;
    }

    public boolean isValidSyntax() {
        return validSyntax;
    }

    private void concatMessage(String msg) {
        this.result += msg;
    }

    private void concatError(Token t, String msg) {
        this.result += msg + " (" + t.image + ") located at [line:" + t.beginLine + "| column:" + t.beginColumn + "]\u005cn";
    }

    public void eraseSemanticRules() {
        languageRules = new LanguageRules();
    }

    public List<Instruction> getSemanticInstructions() {
        return languageRules.getInstructionStack();
    }

    public List<String> getSemanticErrors() {
        return languageRules.getError();
    }

    public boolean isValidSemantic() {
        return !languageRules.haveError();
    }

    public static void main(String[] args) throws ParseException, IOException {
        try {
            LangParser parser = new LangParser(new BufferedReader(new FileReader(args[0])));
            parser.lexicalAnalyzer();
            System.err.println("Program successfully analyzed.");
        } catch (FileNotFoundException e) {
            System.err.println("Erro FileNotFoundException: " + e.getMessage());
        } catch (ParseException e) {
        }
    }

    public static void addRule(String rule, Token t) throws ParseException {
        switch (rule) {
            case "#1":
                languageRules.rule1(t);
                break;
            case "#2":
                languageRules.rule2();
                break;
            case "#3":
                languageRules.rule3(t);
                break;
            case "#4":
                languageRules.rule4(t);
                break;
            case "#5":
                languageRules.rule5();
                break;
            case "#6":
                languageRules.rule6();
                break;
            case "#7":
                languageRules.rule7(t);
                break;
            case "#8":
                languageRules.rule8();
                break;
            case "#9":
                languageRules.rule9(t);
                break;
            case "#10":
                languageRules.rule10(t);
                break;
            case "#11":
                languageRules.rule11();
                break;
            case "#12":
                languageRules.rule12(t);
                break;
            case "#13":
                languageRules.rule13();
                break;
            case "#14":
                languageRules.rule14();
                break;
            case "#15":
                languageRules.rule15();
                break;
            case "#16":
                languageRules.rule16();
                break;
            case "#17":
                languageRules.rule17();
                break;
            case "#18":
                languageRules.rule18();
                break;
            case "#19":
                languageRules.rule19();
                break;
            case "#20":
                languageRules.rule20();
                break;
            case "#21":
                languageRules.rule21();
                break;
            case "#22":
                languageRules.rule22();
                break;
            case "#23":
                languageRules.rule23();
                break;
            case "#24":
                languageRules.rule24(t);
                break;
            case "#25":
                languageRules.rule25();
                break;
            case "#26":
                languageRules.rule26(t);
                break;
            case "#27":
                languageRules.rule27(t);
                break;
            case "#28":
                languageRules.rule28(t);
                break;
            case "#29":
                languageRules.rule29();
                break;
            case "#30":
                languageRules.rule30();
                break;
            case "#31":
                languageRules.rule31();
                break;
            case "#32":
                languageRules.rule32();
                break;
            case "#33":
                languageRules.rule33();
                break;
            case "#34":
                languageRules.rule34();
                break;
            case "#35":
                languageRules.rule35();
                break;
            case "#36":
                languageRules.rule36();
                break;
            case "#37":
                languageRules.rule37();
                break;
            case "#38":
                languageRules.rule38();
                break;
            case "#39":
                languageRules.rule39();
                break;
            case "#40":
                languageRules.rule40();
                break;
            case "#41":
                languageRules.rule41();
                break;
            case "#42":
                languageRules.rule42();
                break;
            case "#43":
                languageRules.rule43();
                break;
            case "#44":
                languageRules.rule44();
                break;
            case "#45":
                languageRules.rule45();
                break;
            case "#46":
                languageRules.rule46();
                break;
            case "#47":
                languageRules.rule47();
                break;
            case "#48":
                languageRules.rule48();
                break;
            case "#49":
                languageRules.rule49();
                break;
            case "#50":
                languageRules.rule50();
                break;
            case "#51":
                languageRules.rule51();
                break;
            case "#52":
                languageRules.rule52();
                break;
            case "#53":
                languageRules.rule53();
                break;
            case "#54":
                languageRules.rule54();
                break;

            default:
                break;
        }
    }

    static public String im(int x) {
        String s = tokenImage[x];
        int k = s.lastIndexOf("\u005c"");
        try {
            s = s.substring(1, k);
        } catch (StringIndexOutOfBoundsException e) {
        }
        return s;
    }

    public void consumeUntil(RecoverySet g, ParseException e) throws ParseException {
        Token tok;
        if (g == null) {
            throw e;
        }
        tok = getToken(1);
        while (!eof) {
            if (g.contains(tok.kind)) {
                break;
            }
            getNextToken();
            tok = getToken(1);
            if (tok.kind == EOF && !g.contains(EOF)) {
                eof = true;
            }
        }
        contParseError++;
    }

    final public void continuationInnerEnumDeclaration() throws ParseException {
        trace_call("continuationInnerEnumDeclaration");
        try {
            Token t;
            t = jj_consume_token(IDENTIFIER);
            addRule("#4", t);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case SEMI_COLUMN: {
                    jj_consume_token(SEMI_COLUMN);
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case LITERAL_CONSTANT: {
                            jj_consume_token(LITERAL_CONSTANT);
                            break;
                        }
                        case INTEGER_NUMERICAL_CONSTANT: {
                            jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                            break;
                        }
                        case REAL_NUMERICAL_CONSTANT: {
                            jj_consume_token(REAL_NUMERICAL_CONSTANT);
                            break;
                        }
                        case IDENTIFIER: {
                            jj_consume_token(IDENTIFIER);
                            break;
                        }
                        default:
                            jj_la1[0] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    continuationInnerEnumDeclaration();
                    break;
                }
                default:
                    jj_la1[1] = jj_gen;
                    ;
            }
        } finally {
            trace_return("continuationInnerEnumDeclaration");
        }
    }

    final public void innerEnumDeclaration(RecoverySet r) throws ParseException {
        trace_call("innerEnumDeclaration");
        try {
            Token t;
            try {
                t = jj_consume_token(IDENTIFIER);
                addRule("#3", t);
                jj_consume_token(IS);
                jj_consume_token(OPEN_KEYS);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case LITERAL_CONSTANT: {
                        jj_consume_token(LITERAL_CONSTANT);
                        break;
                    }
                    case INTEGER_NUMERICAL_CONSTANT: {
                        jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                        break;
                    }
                    case REAL_NUMERICAL_CONSTANT: {
                        jj_consume_token(REAL_NUMERICAL_CONSTANT);
                        break;
                    }
                    case IDENTIFIER: {
                        jj_consume_token(IDENTIFIER);
                        break;
                    }
                    default:
                        jj_la1[2] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                continuationInnerEnumDeclaration();
                jj_consume_token(CLOSE_KEYS);
                jj_consume_token(DOT);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid enum declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("innerEnumDeclaration");
        }
    }

    final public void enumDeclaration(RecoverySet r) throws ParseException {
        trace_call("enumDeclaration");
        try {
            try {
                jj_consume_token(TYPE);
                jj_consume_token(OPEN_BOX);
                label_1:
                while (true) {
                    innerEnumDeclaration(r);
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case IDENTIFIER: {
                            ;
                            break;
                        }
                        default:
                            jj_la1[3] = jj_gen;
                            break label_1;
                    }
                }
                jj_consume_token(CLOSE_BOX);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DECLARATION: {
                        jj_consume_token(DECLARATION);
                        declarationConstantsAndVariables(r);
                        break;
                    }
                    default:
                        jj_la1[4] = jj_gen;
                        ;
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid enum declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("enumDeclaration");
        }
    }

    final public void index() throws ParseException {
        trace_call("index");
        try {
            Token t;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case OPEN_KEYS: {
                    jj_consume_token(OPEN_KEYS);
                    t = jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                    addRule("#12", t);
                    jj_consume_token(CLOSE_KEYS);
                    break;
                }
                default:
                    jj_la1[5] = jj_gen;
                    ;
            }
        } finally {
            trace_return("index");
        }
    }

    final public void item() throws ParseException {
        trace_call("item");
        try {
            Token t;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case IDENTIFIER: {
                    t = jj_consume_token(IDENTIFIER);
                    addRule("#24", t);
                    index();
                    addRule("#25", null);
                    break;
                }
                case INTEGER_NUMERICAL_CONSTANT: {
                    t = jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                    addRule("#26", t);
                    break;
                }
                case REAL_NUMERICAL_CONSTANT: {
                    t = jj_consume_token(REAL_NUMERICAL_CONSTANT);
                    addRule("#27", t);
                    break;
                }
                case LITERAL_CONSTANT: {
                    t = jj_consume_token(LITERAL_CONSTANT);
                    addRule("#28", t);
                    break;
                }
                default:
                    jj_la1[6] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            trace_return("item");
        }
    }

    final public void identifierVariableList() throws ParseException {
        trace_call("identifierVariableList");
        try {
            Token t;
            try {
                t = jj_consume_token(IDENTIFIER);
                addRule("#10", t);
                index();
                addRule("#11", null);
                label_2:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case SEMI_COLUMN: {
                            ;
                            break;
                        }
                        default:
                            jj_la1[7] = jj_gen;
                            break label_2;
                    }
                    identifierVariableOne();
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Incorrect identifier variable", e));
                validSyntax = false;
            }
        } finally {
            trace_return("identifierVariableList");
        }
    }

    final public void identifierVariableOne() throws ParseException {
        trace_call("identifierVariableOne");
        try {
            try {
                jj_consume_token(SEMI_COLUMN);
                identifierVariableList();
            } catch (ParseException e) {
                output.add(new ErrorStruct("Incorrect identifier variable", e));
                validSyntax = false;
            }
        } finally {
            trace_return("identifierVariableOne");
        }
    }

    final public void identifierConstantList() throws ParseException {
        trace_call("identifierConstantList");
        try {
            Token t;
            try {
                t = jj_consume_token(IDENTIFIER);
                addRule("#9", t);
                label_3:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case SEMI_COLUMN: {
                            ;
                            break;
                        }
                        default:
                            jj_la1[8] = jj_gen;
                            break label_3;
                    }
                    identifierConstantOne();
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Incorrect identifier list", e));
                validSyntax = false;
            }
        } finally {
            trace_return("identifierConstantList");
        }
    }

    final public void identifierConstantOne() throws ParseException {
        trace_call("identifierConstantOne");
        try {
            try {
                jj_consume_token(SEMI_COLUMN);
                identifierConstantList();
            } catch (ParseException e) {
                output.add(new ErrorStruct("Incorrect identifier list", e));
                validSyntax = false;
            }
        } finally {
            trace_return("identifierConstantOne");
        }
    }

    final public void typeDeclaration() throws ParseException {
        trace_call("typeDeclaration");
        try {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case INTEGER: {
                    jj_consume_token(INTEGER);
                    addRule("#13", null);
                    break;
                }
                case REAL: {
                    jj_consume_token(REAL);
                    addRule("#14", null);
                    break;
                }
                case STRING: {
                    jj_consume_token(STRING);
                    addRule("#15", null);
                    break;
                }
                case LOGIC: {
                    jj_consume_token(LOGIC);
                    addRule("#16", null);
                    break;
                }
                case IDENTIFIER: {
                    jj_consume_token(IDENTIFIER);
                    addRule("#17", null);
                    break;
                }
                default:
                    jj_la1[9] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            trace_return("typeDeclaration");
        }
    }

    final public void variableDeclaration() throws ParseException {
        trace_call("variableDeclaration");
        try {
            identifierVariableList();
            jj_consume_token(IS);
            typeDeclaration();
            addRule("#6", null);
            jj_consume_token(DOT);
            label_4:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case IDENTIFIER: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[10] = jj_gen;
                        break label_4;
                }
                variableDeclarationOne();
            }
        } finally {
            trace_return("variableDeclaration");
        }
    }

    final public void variableDeclarationOne() throws ParseException {
        trace_call("variableDeclarationOne");
        try {
            variableDeclaration();
        } finally {
            trace_return("variableDeclarationOne");
        }
    }

    final public void constantDeclaration() throws ParseException {
        trace_call("constantDeclaration");
        try {
            Token t;
            identifierConstantList();
            jj_consume_token(IS);
            typeDeclaration();
            addRule("#6", null);
            jj_consume_token(ATTRIBUTION);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case LITERAL_CONSTANT: {
                    t = jj_consume_token(LITERAL_CONSTANT);
                    break;
                }
                case INTEGER_NUMERICAL_CONSTANT: {
                    t = jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                    break;
                }
                case REAL_NUMERICAL_CONSTANT: {
                    t = jj_consume_token(REAL_NUMERICAL_CONSTANT);
                    break;
                }
                default:
                    jj_la1[11] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            addRule("#7", t);
            jj_consume_token(DOT);
            label_5:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case IDENTIFIER: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[12] = jj_gen;
                        break label_5;
                }
                constantDeclarationOne();
            }
        } finally {
            trace_return("constantDeclaration");
        }
    }

    final public void constantDeclarationOne() throws ParseException {
        trace_call("constantDeclarationOne");
        try {
            Token t;
            constantDeclaration();
        } finally {
            trace_return("constantDeclarationOne");
        }
    }

    final public void endConstant() throws ParseException {
        trace_call("endConstant");
        try {
            jj_consume_token(AS);
            startConstant();
        } finally {
            trace_return("endConstant");
        }
    }

    final public void startVariable() throws ParseException {
        trace_call("startVariable");
        try {
            jj_consume_token(VARIABLE);
            addRule("#8", null);
            variableDeclaration();
        } finally {
            trace_return("startVariable");
        }
    }

    final public void startConstant() throws ParseException {
        trace_call("startConstant");
        try {
            jj_consume_token(CONSTANT);
            addRule("#5", null);
            label_6:
            while (true) {
                constantDeclaration();
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case IDENTIFIER: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[13] = jj_gen;
                        break label_6;
                }
            }
        } finally {
            trace_return("startConstant");
        }
    }

    final public void endVariable() throws ParseException {
        trace_call("endVariable");
        try {
            jj_consume_token(AS);
            startVariable();
        } finally {
            trace_return("endVariable");
        }
    }

    final public void startDeclaration(RecoverySet r) throws ParseException {
        trace_call("startDeclaration");
        try {
            try {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case VARIABLE: {
                        startVariable();
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case AS: {
                                endConstant();
                                break;
                            }
                            default:
                                jj_la1[14] = jj_gen;
                                ;
                        }
                        break;
                    }
                    case CONSTANT: {
                        startConstant();
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case AS: {
                                endVariable();
                                break;
                            }
                            default:
                                jj_la1[15] = jj_gen;
                                ;
                        }
                        break;
                    }
                    default:
                        jj_la1[16] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid body declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("startDeclaration");
        }
    }

    final public void innerDeclaration(RecoverySet r) throws ParseException {
        trace_call("innerDeclaration");
        try {
            try {
                jj_consume_token(AS);
                startDeclaration(r);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid body declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("innerDeclaration");
        }
    }

    final public void declarationConstantsAndVariables(RecoverySet r) throws ParseException {
        trace_call("declarationConstantsAndVariables");
        try {
            try {
                jj_consume_token(CONSTANT);
                jj_consume_token(AND);
                jj_consume_token(VARIABLE);
                jj_consume_token(OPEN_BOX);
                innerDeclaration(r);
                jj_consume_token(CLOSE_BOX);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid constant and variable declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("declarationConstantsAndVariables");
        }
    }

    final public void identifierConstantAndVariableList() throws ParseException {
        trace_call("identifierConstantAndVariableList");
        try {
            item();
            addRule("#23", null);
            label_7:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case SEMI_COLUMN: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[17] = jj_gen;
                        break label_7;
                }
                identifierConstantAndVariable();
            }
        } finally {
            trace_return("identifierConstantAndVariableList");
        }
    }

    final public void identifierConstantAndVariable() throws ParseException {
        trace_call("identifierConstantAndVariable");
        try {
            jj_consume_token(SEMI_COLUMN);
            identifierConstantAndVariableList();
        } finally {
            trace_return("identifierConstantAndVariable");
        }
    }

    final public void constants() throws ParseException {
        trace_call("constants");
        try {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case LITERAL_CONSTANT: {
                    jj_consume_token(LITERAL_CONSTANT);
                    break;
                }
                case INTEGER_NUMERICAL_CONSTANT:
                case REAL_NUMERICAL_CONSTANT: {
                    numericConstant();
                    break;
                }
                default:
                    jj_la1[18] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            trace_return("constants");
        }
    }

    final public void numericConstant() throws ParseException {
        trace_call("numericConstant");
        try {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case INTEGER_NUMERICAL_CONSTANT: {
                    jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                    break;
                }
                case REAL_NUMERICAL_CONSTANT: {
                    jj_consume_token(REAL_NUMERICAL_CONSTANT);
                    break;
                }
                default:
                    jj_la1[19] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            trace_return("numericConstant");
        }
    }

    final public void header(RecoverySet r) throws ParseException {
        trace_call("header");
        try {
            Token t;
            try {
                jj_consume_token(DO);
                jj_consume_token(THIS);
                t = jj_consume_token(IDENTIFIER);
                addRule("#1", t);
                jj_consume_token(OPEN_BOX);
                jj_consume_token(CLOSE_BOX);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid program header declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("header");
        }
    }

    final public void declarations(RecoverySet r) throws ParseException {
        trace_call("declarations");
        try {
            try {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DECLARATION: {
                        jj_consume_token(DECLARATION);
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                            case TYPE: {
                                enumDeclaration(r);
                                break;
                            }
                            case CONSTANT: {
                                declarationConstantsAndVariables(r);
                                break;
                            }
                            default:
                                jj_la1[20] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    }
                    default:
                        jj_la1[21] = jj_gen;
                        ;
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid enum/variable declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("declarations");
        }
    }

    final public void expressionContinuation(RecoverySet g) throws ParseException {
        trace_call("expressionContinuation");
        try {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case NOT_EQUAL:
                case EQUAL:
                case GREATER_THEN:
                case LESS_THEN:
                case LESS_EQUALS:
                case GREATER_EQUALS: {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case EQUAL: {
                            jj_consume_token(EQUAL);
                            arithmeticOrLogicExpression(g);
                            addRule("#36", null);
                            break;
                        }
                        case NOT_EQUAL: {
                            jj_consume_token(NOT_EQUAL);
                            arithmeticOrLogicExpression(g);
                            addRule("#37", null);
                            break;
                        }
                        case LESS_THEN: {
                            jj_consume_token(LESS_THEN);
                            arithmeticOrLogicExpression(g);
                            addRule("#38", null);
                            break;
                        }
                        case GREATER_THEN: {
                            jj_consume_token(GREATER_THEN);
                            arithmeticOrLogicExpression(g);
                            addRule("#39", null);
                            break;
                        }
                        case LESS_EQUALS: {
                            jj_consume_token(LESS_EQUALS);
                            arithmeticOrLogicExpression(g);
                            addRule("#40", null);
                            break;
                        }
                        case GREATER_EQUALS: {
                            jj_consume_token(GREATER_EQUALS);
                            arithmeticOrLogicExpression(g);
                            addRule("#41", null);
                            break;
                        }
                        default:
                            jj_la1[22] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    break;
                }
                default:
                    jj_la1[23] = jj_gen;
                    ;
            }
        } finally {
            trace_return("expressionContinuation");
        }
    }

    final public void expression(RecoverySet g) throws ParseException {
        trace_call("expression");
        try {
            try {
                arithmeticOrLogicExpression(g);
                expressionContinuation(g);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid expression declaration", e));
                consumeUntil(g, e);
                validSyntax = false;
            }
        } finally {
            trace_return("expression");
        }
    }

    final public void arithmeticOrLogicExpression(RecoverySet g) throws ParseException {
        trace_call("arithmeticOrLogicExpression");
        try {
            secondTerm(g);
            lesserPriorityOperators(g);
        } finally {
            trace_return("arithmeticOrLogicExpression");
        }
    }

    final public void firstTerm(RecoverySet g) throws ParseException {
        trace_call("firstTerm");
        try {
            element(g);
            topPriorityOperators(g);
        } finally {
            trace_return("firstTerm");
        }
    }

    final public void secondTerm(RecoverySet g) throws ParseException {
        trace_call("secondTerm");
        try {
            firstTerm(g);
            mediumPriorityOperators(g);
        } finally {
            trace_return("secondTerm");
        }
    }

    final public void element(RecoverySet g) throws ParseException {
        trace_call("element");
        try {
            Token t;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                case IDENTIFIER: {
                    t = jj_consume_token(IDENTIFIER);
                    addRule("#24", t);
                    index();
                    addRule("#51", null);
                    break;
                }
                case INTEGER_NUMERICAL_CONSTANT: {
                    t = jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                    addRule("#26", t);
                    break;
                }
                case REAL_NUMERICAL_CONSTANT: {
                    t = jj_consume_token(REAL_NUMERICAL_CONSTANT);
                    addRule("#27", t);
                    break;
                }
                case LITERAL_CONSTANT: {
                    t = jj_consume_token(LITERAL_CONSTANT);
                    addRule("#28", t);
                    break;
                }
                case TRUE: {
                    jj_consume_token(TRUE);
                    addRule("#52", null);
                    break;
                }
                case UNTRUE: {
                    jj_consume_token(UNTRUE);
                    addRule("#53", null);
                    break;
                }
                case OPEN_BRACKETS: {
                    jj_consume_token(OPEN_BRACKETS);
                    expression(g);
                    jj_consume_token(CLOSE_BRACKETS);
                    break;
                }
                case NEGATE_LOGIC: {
                    jj_consume_token(NEGATE_LOGIC);
                    jj_consume_token(OPEN_BRACKETS);
                    expression(g);
                    jj_consume_token(CLOSE_BRACKETS);
                    addRule("#54", null);
                    break;
                }
                default:
                    jj_la1[24] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } finally {
            trace_return("element");
        }
    }

    final public void topPriorityOperators(RecoverySet g) throws ParseException {
        trace_call("topPriorityOperators");
        try {
            label_8:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case POTENCE: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[25] = jj_gen;
                        break label_8;
                }
                jj_consume_token(POTENCE);
                element(g);
                addRule("#50", null);
            }
        } finally {
            trace_return("topPriorityOperators");
        }
    }

    final public void mediumPriorityOperators(RecoverySet g) throws ParseException {
        trace_call("mediumPriorityOperators");
        try {
            label_9:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case AND_LOGIC:
                    case MULTIPLY:
                    case DIVISION:
                    case INTEGER_DIVISION:
                    case DIVISION_REMAINDER: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[26] = jj_gen;
                        break label_9;
                }
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case MULTIPLY: {
                        jj_consume_token(MULTIPLY);
                        firstTerm(g);
                        addRule("#45", null);
                        break;
                    }
                    case DIVISION: {
                        jj_consume_token(DIVISION);
                        firstTerm(g);
                        addRule("#46", null);
                        break;
                    }
                    case INTEGER_DIVISION: {
                        jj_consume_token(INTEGER_DIVISION);
                        firstTerm(g);
                        addRule("#47", null);
                        break;
                    }
                    case DIVISION_REMAINDER: {
                        jj_consume_token(DIVISION_REMAINDER);
                        firstTerm(g);
                        addRule("#48", null);
                        break;
                    }
                    case AND_LOGIC: {
                        jj_consume_token(AND_LOGIC);
                        firstTerm(g);
                        addRule("#49", null);
                        break;
                    }
                    default:
                        jj_la1[27] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } finally {
            trace_return("mediumPriorityOperators");
        }
    }

    final public void lesserPriorityOperators(RecoverySet g) throws ParseException {
        trace_call("lesserPriorityOperators");
        try {
            label_10:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case OR_LOGIC:
                    case PLUS:
                    case MINUS: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[28] = jj_gen;
                        break label_10;
                }
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case PLUS: {
                        jj_consume_token(PLUS);
                        secondTerm(g);
                        addRule("#42", null);
                        break;
                    }
                    case MINUS: {
                        jj_consume_token(MINUS);
                        secondTerm(g);
                        addRule("#43", null);
                        break;
                    }
                    case OR_LOGIC: {
                        jj_consume_token(OR_LOGIC);
                        secondTerm(g);
                        addRule("#44", null);
                        break;
                    }
                    default:
                        jj_la1[29] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } finally {
            trace_return("lesserPriorityOperators");
        }
    }

    final public void repeat(RecoverySet r) throws ParseException {
        trace_call("repeat");
        try {
            RecoverySet g = new RecoverySet(OPEN_BOX);
            RecoverySet h = new RecoverySet(CLOSE_BOX);
            try {
                jj_consume_token(REPEAT);
                jj_consume_token(THIS);
                addRule("#33", null);
                expression(g);
                addRule("#34", null);
                jj_consume_token(OPEN_BOX);
                commandList(h);
                jj_consume_token(CLOSE_BOX);
                addRule("#35", null);
                jj_consume_token(DOT);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid repeat command declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("repeat");
        }
    }

    final public void logicResult(RecoverySet r) throws ParseException {
        trace_call("logicResult");
        try {
            RecoverySet g = new RecoverySet(CLOSE_BOX);
            try {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case TRUE: {
                        jj_consume_token(TRUE);
                        jj_consume_token(RESULT);
                        addRule("#30", null);
                        jj_consume_token(OPEN_BOX);
                        commandList(g);
                        jj_consume_token(CLOSE_BOX);
                        continuationTrueResult();
                        jj_consume_token(DOT);
                        break;
                    }
                    case UNTRUE: {
                        jj_consume_token(UNTRUE);
                        jj_consume_token(RESULT);
                        addRule("#31", null);
                        jj_consume_token(OPEN_BOX);
                        commandList(g);
                        jj_consume_token(CLOSE_BOX);
                        continuationUntrueResult();
                        jj_consume_token(DOT);
                        break;
                    }
                    default:
                        jj_la1[30] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid avaliate bory logic result declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("logicResult");
        }
    }

    final public void continuationTrueResult() throws ParseException {
        trace_call("continuationTrueResult");
        try {
            RecoverySet g = new RecoverySet(CLOSE_BOX);
            try {
                jj_consume_token(UNTRUE);
                jj_consume_token(RESULT);
                addRule("#32", null);
                jj_consume_token(OPEN_BOX);
                commandList(g);
                jj_consume_token(CLOSE_BOX);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid avaliate bory logic result declaration", e));
                consumeUntil(g, e);
                validSyntax = false;
            }
        } finally {
            trace_return("continuationTrueResult");
        }
    }

    final public void continuationUntrueResult() throws ParseException {
        trace_call("continuationUntrueResult");
        try {
            RecoverySet g = new RecoverySet(CLOSE_BOX);
            try {
                jj_consume_token(TRUE);
                jj_consume_token(RESULT);
                addRule("#32", null);
                jj_consume_token(OPEN_BOX);
                commandList(g);
                jj_consume_token(CLOSE_BOX);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid avaliate bory logic result declaration", e));
                consumeUntil(g, e);
                validSyntax = false;
            }
        } finally {
            trace_return("continuationUntrueResult");
        }
    }

    final public void avaliate(RecoverySet r) throws ParseException {
        trace_call("avaliate");
        try {
            RecoverySet g = new RecoverySet(DOT);
            try {
                jj_consume_token(AVALIATE);
                jj_consume_token(THIS);
                expression(First.avaliate);
                logicResult(g);
                addRule("#29", null);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid avaliate command declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("avaliate");
        }
    }

    final public void write(RecoverySet g) throws ParseException {
        trace_call("write");
        try {
            try {
                jj_consume_token(THIS);
                addRule("#22", null);
                jj_consume_token(OPEN_BOX);
                identifierConstantAndVariableList();
                jj_consume_token(CLOSE_BOX);
                jj_consume_token(DOT);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid write command declaration", e));
                consumeUntil(g, e);
                validSyntax = false;
            }
        } finally {
            trace_return("write");
        }
    }

    final public void writeAll(RecoverySet g) throws ParseException {
        trace_call("writeAll");
        try {
            try {
                jj_consume_token(ALL);
                jj_consume_token(THIS);
                addRule("#21", null);
                jj_consume_token(OPEN_BOX);
                identifierConstantAndVariableList();
                jj_consume_token(CLOSE_BOX);
                jj_consume_token(DOT);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid write all command declaration", e));
                consumeUntil(g, e);
                validSyntax = false;
            }
        } finally {
            trace_return("writeAll");
        }
    }

    final public void designate(RecoverySet r) throws ParseException {
        trace_call("designate");
        try {
            RecoverySet h = new RecoverySet(DOT);
            try {
                jj_consume_token(DESIGNATE);
                jj_consume_token(THIS);
                addRule("#18", null);
                identifierVariableList();
                jj_consume_token(AS);
                expression(h);
                addRule("#19", null);
                jj_consume_token(DOT);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid designate command declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("designate");
        }
    }

    final public void read(RecoverySet r) throws ParseException {
        trace_call("read");
        try {
            try {
                jj_consume_token(READ);
                jj_consume_token(THIS);
                addRule("#20", null);
                jj_consume_token(OPEN_BOX);
                identifierVariableList();
                jj_consume_token(CLOSE_BOX);
                jj_consume_token(DOT);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid read command declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("read");
        }
    }

    final public void commandList(RecoverySet r) throws ParseException {
        trace_call("commandList");
        try {
            RecoverySet g = First.commandList;
            try {
                label_11:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case REPEAT: {
                            repeat(g);
                            break;
                        }
                        case AVALIATE: {
                            avaliate(g);
                            break;
                        }
                        case WRITE: {
                            jj_consume_token(WRITE);
                            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                                case THIS: {
                                    write(g);
                                    break;
                                }
                                case ALL: {
                                    writeAll(g);
                                    break;
                                }
                                default:
                                    jj_la1[31] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            break;
                        }
                        case DESIGNATE: {
                            designate(g);
                            break;
                        }
                        case READ: {
                            read(g);
                            break;
                        }
                        default:
                            jj_la1[32] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                        case READ:
                        case WRITE:
                        case REPEAT:
                        case AVALIATE:
                        case DESIGNATE: {
                            ;
                            break;
                        }
                        default:
                            jj_la1[33] = jj_gen;
                            break label_11;
                    }
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid command list declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("commandList");
        }
    }

    final public void body(RecoverySet r) throws ParseException {
        trace_call("body");
        try {
            RecoverySet g = new RecoverySet(OPEN_BOX);
            try {
                jj_consume_token(BODY);
                jj_consume_token(OPEN_BOX);
                commandList(g);
                jj_consume_token(CLOSE_BOX);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid body declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("body");
        }
    }

    final public void desc(RecoverySet r) throws ParseException {
        trace_call("desc");
        try {
            try {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DESCRIPTION: {
                        jj_consume_token(DESCRIPTION);
                        jj_consume_token(LITERAL_CONSTANT);
                        break;
                    }
                    default:
                        jj_la1[34] = jj_gen;
                        ;
                }
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid description declaration", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("desc");
        }
    }

    final public void parser(RecoverySet r) throws ParseException {
        trace_call("parser");
        try {
            RecoverySet h = new RecoverySet(BODY);
            RecoverySet g = new RecoverySet(DECLARATION);
            RecoverySet i = g.union(h);
            RecoverySet l = new RecoverySet(DESCRIPTION);
            try {
                header(i);
                declarations(h);
                body(r.union(l));
                desc(r);
                addRule("#2", null);
            } catch (ParseException e) {
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("parser");
        }
    }

    final public void syntaxAnalyzer() throws ParseException {
        trace_call("syntaxAnalyzer");
        try {
            RecoverySet r = new RecoverySet(EOF);
            try {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DO: {
                        parser(r);
                        break;
                    }
                    default:
                        jj_la1[35] = jj_gen;
                        ;
                }
                jj_consume_token(0);
            } catch (ParseException e) {
                output.add(new ErrorStruct("Invalid general form of the program", e));
                consumeUntil(r, e);
                validSyntax = false;
            }
        } finally {
            trace_return("syntaxAnalyzer");
        }
    }

    final public void lexicalAnalyzer() throws ParseException {
        trace_call("lexicalAnalyzer");
        try {
            label_12:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DO:
                    case IS:
                    case AS:
                    case AND:
                    case ALL:
                    case THIS:
                    case BODY:
                    case TYPE:
                    case REAL:
                    case STRING:
                    case LOGIC:
                    case ENUM:
                    case READ:
                    case WRITE:
                    case REPEAT:
                    case VARIABLE:
                    case CONSTANT:
                    case RESULT:
                    case INTEGER:
                    case AVALIATE:
                    case DESCRIPTION:
                    case DECLARATION:
                    case DESIGNATE:
                    case TRUE:
                    case UNTRUE:
                    case OR_LOGIC:
                    case AND_LOGIC:
                    case NEGATE_LOGIC:
                    case PLUS:
                    case SUBTRACTION:
                    case MULTIPLY:
                    case DIVISION:
                    case INTEGER_DIVISION:
                    case DIVISION_REMAINDER:
                    case POTENCE:
                    case NOT_EQUAL:
                    case ATTRIBUTION:
                    case EQUAL:
                    case GREATER_THEN:
                    case LESS_THEN:
                    case LESS_EQUALS:
                    case GREATER_EQUALS:
                    case OPEN_KEYS:
                    case CLOSE_KEYS:
                    case OPEN_BOX:
                    case CLOSE_BOX:
                    case OPEN_BRACKETS:
                    case CLOSE_BRACKETS:
                    case SEMI_COLUMN:
                    case DOT:
                    case IDENTIFIER:
                    case INVALID_IDENTIFIER:
                    case LITERAL_CONSTANT:
                    case ERROR_LITERAL_CONSTANT:
                    case INTEGER_NUMERICAL_CONSTANT:
                    case REAL_NUMERICAL_CONSTANT:
                    case INVALID_INTEGER_NUMERICAL_CONSTANT:
                    case INVALID_REAL_NUMERICAL_CONSTANT:
                    case ASCII: {
                        ;
                        break;
                    }
                    default:
                        jj_la1[36] = jj_gen;
                        break label_12;
                }
                lexer();
            }
            jj_consume_token(0);
        } finally {
            trace_return("lexicalAnalyzer");
        }
    }

    final public void lexer() throws ParseException {
        trace_call("lexer");
        try {
            Token t;
            try {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
                    case DO: {
                        t = jj_consume_token(DO);
                        System.out.println("DO: " + t.image);
                        break;
                    }
                    case IS: {
                        t = jj_consume_token(IS);
                        System.out.println("IS: " + t.image);
                        break;
                    }
                    case AS: {
                        t = jj_consume_token(AS);
                        System.out.println("AS: " + t.image);
                        break;
                    }
                    case AND: {
                        t = jj_consume_token(AND);
                        System.out.println("AND: " + t.image);
                        break;
                    }
                    case ALL: {
                        t = jj_consume_token(ALL);
                        System.out.println("ALL: " + t.image);
                        break;
                    }
                    case THIS: {
                        t = jj_consume_token(THIS);
                        System.out.println("THIS: " + t.image);
                        break;
                    }
                    case BODY: {
                        t = jj_consume_token(BODY);
                        System.out.println("BODY: " + t.image);
                        break;
                    }
                    case TYPE: {
                        t = jj_consume_token(TYPE);
                        System.out.println("TYPE: " + t.image);
                        break;
                    }
                    case REAL: {
                        t = jj_consume_token(REAL);
                        System.out.println("REAL: " + t.image);
                        break;
                    }
                    case STRING: {
                        t = jj_consume_token(STRING);
                        System.out.println("STRING: " + t.image);
                        break;
                    }
                    case LOGIC: {
                        t = jj_consume_token(LOGIC);
                        System.out.println("LOGIC: " + t.image);
                        break;
                    }
                    case ENUM: {
                        t = jj_consume_token(ENUM);
                        System.out.println("ENUM: " + t.image);
                        break;
                    }
                    case READ: {
                        t = jj_consume_token(READ);
                        System.out.println("READ: " + t.image);
                        break;
                    }
                    case WRITE: {
                        t = jj_consume_token(WRITE);
                        System.out.println("WRITE: " + t.image);
                        break;
                    }
                    case REPEAT: {
                        t = jj_consume_token(REPEAT);
                        System.out.println("REPEAT: " + t.image);
                        break;
                    }
                    case VARIABLE: {
                        t = jj_consume_token(VARIABLE);
                        System.out.println("VARIABLE: " + t.image);
                        break;
                    }
                    case CONSTANT: {
                        t = jj_consume_token(CONSTANT);
                        System.out.println("CONSTANT: " + t.image);
                        break;
                    }
                    case RESULT: {
                        t = jj_consume_token(RESULT);
                        System.out.println("RESULT: " + t.image);
                        break;
                    }
                    case INTEGER: {
                        t = jj_consume_token(INTEGER);
                        System.out.println("INTEGER: " + t.image);
                        break;
                    }
                    case AVALIATE: {
                        t = jj_consume_token(AVALIATE);
                        System.out.println("AVALIATE: " + t.image);
                        break;
                    }
                    case DESCRIPTION: {
                        t = jj_consume_token(DESCRIPTION);
                        System.out.println("DESCRIPTION: " + t.image);
                        break;
                    }
                    case DECLARATION: {
                        t = jj_consume_token(DECLARATION);
                        System.out.println("DECLARATION: " + t.image);
                        break;
                    }
                    case DESIGNATE: {
                        t = jj_consume_token(DESIGNATE);
                        System.out.println("DESIGNATE: " + t.image);
                        break;
                    }
                    case TRUE: {
                        t = jj_consume_token(TRUE);
                        System.out.println("TRUE: " + t.image);
                        break;
                    }
                    case UNTRUE: {
                        t = jj_consume_token(UNTRUE);
                        System.out.println("UNTRUE: " + t.image);
                        break;
                    }
                    case NOT_EQUAL: {
                        t = jj_consume_token(NOT_EQUAL);
                        System.out.println("NOT_EQUAL: " + t.image);
                        break;
                    }
                    case ATTRIBUTION: {
                        t = jj_consume_token(ATTRIBUTION);
                        System.out.println("ATTRIBUTION: " + t.image);
                        break;
                    }
                    case EQUAL: {
                        t = jj_consume_token(EQUAL);
                        System.out.println("EQUAL: " + t.image);
                        break;
                    }
                    case GREATER_THEN: {
                        t = jj_consume_token(GREATER_THEN);
                        System.out.println("GREATER_THEN: " + t.image);
                        break;
                    }
                    case LESS_THEN: {
                        t = jj_consume_token(LESS_THEN);
                        System.out.println("LESS_THEN: " + t.image);
                        break;
                    }
                    case LESS_EQUALS: {
                        t = jj_consume_token(LESS_EQUALS);
                        System.out.println("LESS_EQUALS: " + t.image);
                        break;
                    }
                    case GREATER_EQUALS: {
                        t = jj_consume_token(GREATER_EQUALS);
                        System.out.println("GREATER_EQUALS: " + t.image);
                        break;
                    }
                    case OR_LOGIC: {
                        t = jj_consume_token(OR_LOGIC);
                        System.out.println("OR_LOGIC: " + t.image);
                        break;
                    }
                    case AND_LOGIC: {
                        t = jj_consume_token(AND_LOGIC);
                        System.out.println("AND_LOGIC: " + t.image);
                        break;
                    }
                    case NEGATE_LOGIC: {
                        t = jj_consume_token(NEGATE_LOGIC);
                        System.out.println("NEGATE_LOGIC: " + t.image);
                        break;
                    }
                    case PLUS: {
                        t = jj_consume_token(PLUS);
                        System.out.println("PLUS: " + t.image);
                        break;
                    }
                    case SUBTRACTION: {
                        t = jj_consume_token(SUBTRACTION);
                        System.out.println("SUBTRACTION: " + t.image);
                        break;
                    }
                    case MULTIPLY: {
                        t = jj_consume_token(MULTIPLY);
                        System.out.println("MULTIPLY: " + t.image);
                        break;
                    }
                    case DIVISION: {
                        t = jj_consume_token(DIVISION);
                        System.out.println("DIVISION: " + t.image);
                        break;
                    }
                    case INTEGER_DIVISION: {
                        t = jj_consume_token(INTEGER_DIVISION);
                        System.out.println("INTEGER_DIVISION: " + t.image);
                        break;
                    }
                    case DIVISION_REMAINDER: {
                        t = jj_consume_token(DIVISION_REMAINDER);
                        System.out.println("DIVISION_REMAINDER: " + t.image);
                        break;
                    }
                    case POTENCE: {
                        t = jj_consume_token(POTENCE);
                        System.out.println("POTENCE: " + t.image);
                        break;
                    }
                    case SEMI_COLUMN: {
                        t = jj_consume_token(SEMI_COLUMN);
                        System.out.println("SEMI_COLUMN: " + t.image);
                        break;
                    }
                    case DOT: {
                        t = jj_consume_token(DOT);
                        System.out.println("DOT: " + t.image);
                        break;
                    }
                    case OPEN_KEYS: {
                        t = jj_consume_token(OPEN_KEYS);
                        System.out.println("OPEN_KEYS: " + t.image);
                        break;
                    }
                    case CLOSE_KEYS: {
                        t = jj_consume_token(CLOSE_KEYS);
                        System.out.println("CLOSE_KEYS: " + t.image);
                        break;
                    }
                    case OPEN_BOX: {
                        t = jj_consume_token(OPEN_BOX);
                        System.out.println("OPEN_BOX: " + t.image);
                        break;
                    }
                    case CLOSE_BOX: {
                        t = jj_consume_token(CLOSE_BOX);
                        System.out.println("CLOSE_BOX: " + t.image);
                        break;
                    }
                    case OPEN_BRACKETS: {
                        t = jj_consume_token(OPEN_BRACKETS);
                        System.out.println("OPEN_BRACKETS: " + t.image);
                        break;
                    }
                    case CLOSE_BRACKETS: {
                        t = jj_consume_token(CLOSE_BRACKETS);
                        System.out.println("CLOSE_BRACKETS: " + t.image);
                        break;
                    }
                    case IDENTIFIER: {
                        t = jj_consume_token(IDENTIFIER);
                        System.out.println("IDENTIFIER: " + t.image);
                        break;
                    }
                    case INTEGER_NUMERICAL_CONSTANT: {
                        t = jj_consume_token(INTEGER_NUMERICAL_CONSTANT);
                        System.out.println("INTEGER_NUMERICAL_CONSTANT: " + t.image);
                        break;
                    }
                    case REAL_NUMERICAL_CONSTANT: {
                        t = jj_consume_token(REAL_NUMERICAL_CONSTANT);
                        System.out.println("REAL_NUMERICAL_CONSTANT: " + t.image);
                        break;
                    }
                    case LITERAL_CONSTANT: {
                        t = jj_consume_token(LITERAL_CONSTANT);
                        System.out.println("LITERAL_CONSTANT: " + t.image);
                        break;
                    }
                    case ERROR_LITERAL_CONSTANT: {
                        t = jj_consume_token(ERROR_LITERAL_CONSTANT);
                        concatError(t, "Literal constant quote not ended");
                        validLexical = false;
                        break;
                    }
                    case INVALID_IDENTIFIER: {
                        t = jj_consume_token(INVALID_IDENTIFIER);
                        concatError(t, "Invalid Indentifier");
                        validLexical = false;
                        break;
                    }
                    case INVALID_INTEGER_NUMERICAL_CONSTANT: {
                        t = jj_consume_token(INVALID_INTEGER_NUMERICAL_CONSTANT);
                        concatError(t, "Invalid Numerical Constant");
                        validLexical = false;
                        break;
                    }
                    case INVALID_REAL_NUMERICAL_CONSTANT: {
                        t = jj_consume_token(INVALID_REAL_NUMERICAL_CONSTANT);
                        concatError(t, "Invalid Real Constant");
                        validLexical = false;
                        break;
                    }
                    case ASCII: {
                        t = jj_consume_token(ASCII);
                        concatError(t, "Unidentified Token");
                        validLexical = false;
                        break;
                    }
                    default:
                        jj_la1[37] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            } catch (ParseException e) {

            }
        } finally {
            trace_return("lexer");
        }
    }

    /**
     * Generated Token Manager.
     */
    public LangParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[38];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
        jj_la1_init_2();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40700000, 0x0, 0x0, 0x0, 0x0, 0x4000, 0x4000, 0x18000000, 0x0, 0x0, 0x0, 0x10080000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30000, 0x87000000, 0x87000000, 0x0, 0x1000, 0xfffff000, 0xfffff000,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x40000000, 0x10000000, 0x40000000, 0x40000000, 0x2, 0x400000, 0x40000000, 0x10000000, 0x10000000, 0x40000000, 0x40000000, 0x0, 0x40000000, 0x40000000, 0x0, 0x0, 0x0, 0x10000000, 0x0, 0x0, 0x0, 0x2, 0x3e8000, 0x3e8000, 0x44000098, 0x4000, 0x3c40, 0x3c40, 0x120, 0x120, 0x18, 0x0, 0x4, 0x4, 0x1, 0x0, 0xffffffff, 0xffffffff,};
    }

    private static void jj_la1_init_2() {
        jj_la1_2 = new int[]{0x31, 0x0, 0x31, 0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x31, 0x30, 0x0, 0x0, 0x0, 0x0, 0x31, 0x0, 0x0, 0x0, 0x400, 0x400, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20f9, 0x20f9,};
    }

    /**
     * Constructor with InputStream.
     */
    public LangParser(java.io.InputStream stream) {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public LangParser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new LangParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor.
     */
    public LangParser(java.io.Reader stream) {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new LangParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    }

    /**
     * Constructor with generated Token Manager.
     */
    public LangParser(LangParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(LangParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            trace_token(token, "");
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        trace_token(token, " (in getNextToken)");
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk_f() {
        if ((jj_nt = token.next) == null) return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[81];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 38; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 81; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private int trace_indent = 0;
    private boolean trace_enabled = true;

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
        trace_enabled = true;
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
        trace_enabled = false;
    }

    private void trace_call(String s) {
        if (trace_enabled) {
            for (int i = 0; i < trace_indent; i++) {
                System.out.print(" ");
            }
            System.out.println("Call:   " + s);
        }
        trace_indent = trace_indent + 2;
    }

    private void trace_return(String s) {
        trace_indent = trace_indent - 2;
        if (trace_enabled) {
            for (int i = 0; i < trace_indent; i++) {
                System.out.print(" ");
            }
            System.out.println("Return: " + s);
        }
    }

    private void trace_token(Token t, String where) {
        if (trace_enabled) {
            for (int i = 0; i < trace_indent; i++) {
                System.out.print(" ");
            }
            System.out.print("Consumed token: <" + tokenImage[t.kind]);
            if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
                System.out.print(": \"" + t.image + "\"");
            }
            System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
        }
    }

    private void trace_scan(Token t1, int t2) {
        if (trace_enabled) {
            for (int i = 0; i < trace_indent; i++) {
                System.out.print(" ");
            }
            System.out.print("Visited token: <" + tokenImage[t1.kind]);
            if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
                System.out.print(": \"" + t1.image + "\"");
            }
            System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
        }
    }

}
