options {
    STATIC = false;
    TOKEN_FACTORY = "Token";
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    DEBUG_PARSER = true;

}

PARSER_BEGIN(LexicalAnalysis)
import java.io.*;

public class LexicalAnalysis {

        private String result = "";
        private boolean validLexical = true;

        public String getResult(){
            return result;
        }

        public void setResult(String result){
            this.result = result;
        }
        public boolean isValidLexical(){
            return validLexical;
        }

        private void concatMessage(Token t) {
            this.result += "Found token: (" + t.image + ") located at [line:" + t.beginLine + " | column:" + t.beginColumn + "]\n";
        }

       private void concatError(Token t){
            this.result += "Invalid token (" + t.image + ") located at [line:"+t.beginLine+"| column:"+t.beginColumn+"]\n";
       }

       private void concatError(Token t, String msg){
            this.result += msg + " (" + t.image + ") located at [line:"+t.beginLine+"| column:"+t.beginColumn+"]\n";
       }

        public static void main(String[] args) throws ParseException, IOException {
            try {
                LexicalAnalysis parser = new LexicalAnalysis(
                     new BufferedReader(new FileReader(args[0]))
                );
                parser.MainRule();
                System.err.println("Program successfully analyzed.");
            } catch (FileNotFoundException e) {
                System.err.println("Erro FileNotFoundException: " + e.getMessage());
            } catch (ParseException e) {
                System.err.println("Erro ParseException: " + e.getMessage());
            }
        }


}
PARSER_END(LexicalAnalysis)

<DEFAULT> SKIP : { " "
                 | "\t"
                 | "\n"
                 | "\r"
                 | "\f"
}

<AFTER_EGEN> SKIP : {
  <~[]> : DEFAULT
}

SKIP : {
  "/*" : multilinecomment
}

SKIP : {
  "//" : singlelinecomment
}

<multilinecomment> SKIP: {
   <"*/"> : DEFAULT

}

<singlelinecomment> SKIP: {
   <["\n","\r"]> : DEFAULT
|   <~[]>
}


/*
 * Java reserved words and literals
 */
<DEFAULT> TOKEN  [IGNORE_CASE]: {
              <DO: "do">
            | <IS: "is">
            | <AS: "as">
            | <AND: "and">
            | <ALL: "all">
            | <THIS: "this">
            | <BODY: "body">
            | <TYPE: "type">
            | <REAL: "real">
            | <STRING: "string">
            | <LOGIC: "logic">
            | <ENUM: "enum">
            | <READ: "read">
            | <WRITE: "write">
            | <REPEAT: "repeat">
            | <VARIABLE: "variable">
            | <CONSTANT: "constant">
            | <RESULT: "result">
            | <INTEGER: "integer">
            | <AVALIATE: "avaliate">
            | <DESCRIPTION: "description">
            | <DECLARATION: "declaration">
            | <DESIGNATE: "designate">
}

<DEFAULT> TOKEN  [IGNORE_CASE]: {
              <TRUE: "true">
            | <UNTRUE: "untrue">
}

/*
 * Operators
 */
<DEFAULT> TOKEN : {
              <OR_LOGIC: "|">
            | <AND_LOGIC: "&">
            | <NEGATE_LOGIC : "!">
            | <PLUS: "+">
            | <SUBTRACTION: "-">
            | <MULTIPLY: "*">
            | <DIVISION: "/">
            | <INTEGER_DIVISION: "%">
            | <DIVISION_REMAINDER: "%%">
            | <POTENCE: "**">
            | <NOT_EQUAL: "!=">
            | <ATTRIBUTION: "=">
            | <EQUAL: "==">
            | <GREATERTHEN: ">>">
            | <LESSTHEN: "<<">
            | <LESS_EQUALS: "<<=">
            | <GREATER_EQUALS: ">>=">
}

/*
 * Separators
 */
<DEFAULT> TOKEN : {
              <OPEN_KEYS: "{">
            | <CLOSE_KEYS: "}">
            | <OPEN_BOX: "[">
            | <CLOSE_BOX: "]">
            | <OPEN_BRACKETS: "(">
            | <CLOSE_BRACKETS: ")">
}

<DEFAULT> TOKEN : {
              <SEMI_COLUMN: ",">
            | <DOT: ".">
}



<DEFAULT> TOKEN : {
   <IDENTIFIER : (<CAPITAL_LETTER>)+ (<SYMBOL>)?(
       (<LETTER>)* |
       <LETTER> <SYMBOL> |
       <DIGIT> <DIGIT> <LETTER> |
       <DIGIT> <DIGIT> <SYMBOL> |
       <DIGIT> <LETTER> |
       <DIGIT> <SYMBOL> |
       <DIGIT> <SYMBOL> <LETTER> |
       <DIGIT> <DIGIT> <SYMBOL> <LETTER> |
       <DIGIT> (<LETTER>)+ <SYMBOL> |
       <DIGIT> <DIGIT> (<LETTER>)+ <SYMBOL>
   )*>
}

TOKEN : {
      <LITERAL_CONSTANT: <DOUBLE_QUOTE_CONST> | <SINGLE_QUOTE_CONST> >
     |
       <DOUBLE_QUOTE_CONST: (<DOUBLE_QUOTE> (~["\""])* <DOUBLE_QUOTE>) >
     |
       <SINGLE_QUOTE_CONST: (<SINGLE_QUOTE> (~["\'"])* <SINGLE_QUOTE>) >
     |
       <ERROR_LITERAL_CONSTANT: <SINGLE_QUOTE> (~["\'"])*
                            | <DOUBLE_QUOTE> (~["\""])*>
}

TOKEN : {
      <INTEGER_NUMERICAL_CONSTANT : <DIGIT> (<DIGIT>)? (<DIGIT>)?>
    | <REAL_NUMERICAL_CONSTANT : <DIGIT> (<DIGIT>)? (<DIGIT>)? (<DIGIT>)? (<DIGIT>)? "." <DIGIT>(<DIGIT>)? (<DIGIT>)?>


}


TOKEN : {

    <ASCII: (~[])>
  | <DIGIT: ["0"-"9"]>
  | <SYMBOL: ["_"]>
  | <MINUS: ("-"){1}>
  | <SINGLE_QUOTE: "'">
  | <DOUBLE_QUOTE: "\"">
  | <SMALL_LETTER : ["a"-"z"]>
  | <CAPITAL_LETTER : ["A"-"Z"]>
  | <LETTER: ["A"-"Z","a"-"z"]>

}
TOKEN : {
  <OTHER: ~[]>
}


void MainRule():{}{
     (lexicalAnalyzer())*
     <EOF>
}




void lexicalAnalyzer() : {
    Token t;
}
{
try {
    t = <DO> { System.out.println("DO: " + t.image); }
  | t = <IS> { System.out.println("IS: " + t.image); }
  | t = <AS> { System.out.println("AS: " + t.image); }
  | t = <AND> { System.out.println("AND: " + t.image); }
  | t = <ALL> { System.out.println("ALL: " + t.image); }
  | t = <THIS> { System.out.println("THIS: " + t.image); }
  | t = <BODY> { System.out.println("BODY: " + t.image); }
  | t = <TYPE> { System.out.println("TYPE: " + t.image); }
  | t = <REAL> { System.out.println("REAL: " + t.image); }
  | t = <STRING> { System.out.println("STRING: " + t.image); }
  | t = <LOGIC> { System.out.println("LOGIC: " + t.image); }
  | t = <ENUM> { System.out.println("ENUM: " + t.image); }
  | t = <READ> { System.out.println("READ: " + t.image); }
  | t = <WRITE> { System.out.println("WRITE: " + t.image); }
  | t = <REPEAT> { System.out.println("REPEAT: " + t.image); }
  | t = <VARIABLE> { System.out.println("VARIABLE: " + t.image); }
  | t = <CONSTANT> { System.out.println("CONSTANT: " + t.image); }
  | t = <RESULT> { System.out.println("RESULT: " + t.image); }
  | t = <INTEGER> { System.out.println("INTEGER: " + t.image); }
  | t = <AVALIATE> { System.out.println("AVALIATE: " + t.image); }
  | t = <DESCRIPTION> { System.out.println("DESCRIPTION: " + t.image); }
  | t = <DECLARATION> { System.out.println("DECLARATION: " + t.image); }
  | t = <DESIGNATE> { System.out.println("DESIGNATE: " + t.image); }
  | t = <TRUE> { System.out.println("TRUE: " + t.image); }
  | t = <UNTRUE> { System.out.println("UNTRUE: " + t.image); }
  | t = <NOT_EQUAL> { System.out.println("NOT_EQUAL: " + t.image); }
  | t = <ATTRIBUTION> { System.out.println("ATTRIBUTION: " + t.image); }
  | t = <EQUAL> { System.out.println("EQUAL: " + t.image); }
  | t = <GREATERTHEN> { System.out.println("GREATERTHEN: " + t.image); }
  | t = <LESSTHEN> { System.out.println("LESSTHEN: " + t.image); }
  | t = <LESS_EQUALS> { System.out.println("LESS_EQUALS: " + t.image); }
  | t = <GREATER_EQUALS> { System.out.println("GREATER_EQUALS: " + t.image); }
  | t = <OR_LOGIC> { System.out.println("OR_LOGIC: " + t.image); }
  | t = <AND_LOGIC> { System.out.println("AND_LOGIC: " + t.image); }
  | t = <NEGATE_LOGIC> { System.out.println("NEGATE_LOGIC: " + t.image); }
  | t = <PLUS> { System.out.println("PLUS: " + t.image); }
  | t = <SUBTRACTION> { System.out.println("SUBTRACTION: " + t.image); }
  | t = <MULTIPLY> { System.out.println("MULTIPLY: " + t.image); }
  | t = <DIVISION> { System.out.println("DIVISION: " + t.image); }
  | t = <INTEGER_DIVISION> { System.out.println("INTEGER_DIVISION: " + t.image); }
  | t = <DIVISION_REMAINDER> { System.out.println("DIVISION_REMAINDER: " + t.image); }
  | t = <POTENCE> { System.out.println("POTENCE: " + t.image); }
  | t = <SEMI_COLUMN> { System.out.println("SEMI_COLUMN: " + t.image); }
  | t = <DOT> { System.out.println("DOT: " + t.image); }
  | t = <OPEN_KEYS> { System.out.println("OPEN_KEYS: " + t.image); }
  | t = <CLOSE_KEYS> { System.out.println("CLOSE_KEYS: " + t.image); }
  | t = <OPEN_BOX> { System.out.println("OPEN_BOX: " + t.image); }
  | t = <CLOSE_BOX> { System.out.println("CLOSE_BOX: " + t.image); }
  | t = <OPEN_BRACKETS> { System.out.println("OPEN_BRACKETS: " + t.image); }
  | t = <CLOSE_BRACKETS> { System.out.println("CLOSE_BRACKETS: " + t.image); }
  | t = <IDENTIFIER> { System.out.println("IDENTIFIER: " + t.image); }
  | t = <INTEGER_NUMERICAL_CONSTANT> { System.out.println("INTEGER_NUMERICAL_CONSTANT: " + t.image); }
  | t = <REAL_NUMERICAL_CONSTANT> { System.out.println("REAL_NUMERICAL_CONSTANT: " + t.image); }
  | t = <LITERAL_CONSTANT> { System.out.println("LITERAL_CONSTANT: " + t.image); }
  | t = <ERROR_LITERAL_CONSTANT> { concatError(t, "Literal constant quote not ended"); validLexical = false; }
  | t = <ASCII> { concatError(t); validLexical = false;  }
  } catch (ParseException e){

  }

}

